/* eslint-disable @typescript-eslint/no-unused-vars */

import Koa from "koa"
import Router from "koa-router"
import bodyParser from "koa-bodyparser"
import websocket from "koa-easy-ws"

import cors from "@koa/cors"

import WebSocket from "ws"
import { PongWS, filterPingPongMessages } from "@cs125/pingpongws"

import { ConnectionQuery, Versions, JoinMessage, RoomsMessage, ChitterMessage } from "../types"

import { OAuth2Client } from "google-auth-library"
import { String } from "runtypes"
const VERSIONS = {
  commit: String.check(process.env.GIT_COMMIT),
  server: String.check(process.env.npm_package_version),
}

// This is just vanilla TypeScript, not React TypeScript.

// Set up Koa instance and router
const app = new Koa()
const router = new Router<Record<string, unknown>, { ws: () => Promise<WebSocket> }>()

// Possible useful type aliases, just to make our mappings and function declarations more clear
type ClientID = string
type RoomID = string

// Different mappings we need to maintain, so that we can:
//
// 1. Figure out what websockets should receive a message sent to a room
// 2. Figure out what rooms a particular websocket has joined

const clientIDtoWebsocket: Record<ClientID, WebSocket> = {}
const roomToClientIDs: Record<RoomID, Record<ClientID, boolean>> = {}
const clientIDtoRooms: Record<ClientID, Record<RoomID, boolean>> = {}

router.get("/", async (ctx) => {
  const connectionQuery = ConnectionQuery.check(ctx.request.query)
  // clientID is a distinct UUID but stable for each tab, generated by the client
  const { clientID, version, commit } = connectionQuery

  // Should be saved with messages for auditing purposes
  const versions = Versions.check({
    version: {
      server: VERSIONS.server,
      client: version,
    },
    commit: {
      server: VERSIONS.commit,
      client: commit,
    },
  })

  // TODO: eventually require login, since we'll need this to determine who can join various rooms,
  // but for now just set the email to a debugging value
  const email = "student@illinois.edu"

  const ws = PongWS(await ctx.ws())
  // TODO: Update various mappings appropriately

  // We'll expect the client to remember what rooms it wants to join
  clientIDtoRooms[clientID] = {}
  clientIDtoWebsocket[clientID] = ws

  ws.addEventListener(
    "message",
    filterPingPongMessages(async ({ data }) => {
      // Handle incoming messages here
      const message = JSON.parse(data.toString())
      // .guard() checks if the data of message matches the shape of JoinMessage as a type
      if (ChitterMessage.guard(message)) {
        message.displayName = await retrieveDisplayName(message.googleIDToken)
        // Send message to all components that are subscribed to the room.
        // Get the Client ID's from the message
        const { clientID, room } = message
        const allClients = Object.keys(roomToClientIDs[room])
        const allWebSockets: WebSocket[] = []
        allClients.forEach((key) => {
          allWebSockets.push(clientIDtoWebsocket[key])
        })
        allWebSockets.forEach((ws) => {
          ws.send(JSON.stringify(message))
        })
        // See if we can send the message back!
      } else if (JoinMessage.guard(message)) {
        // TODO: handle join message by updating client and room mappings
        const { roomID } = message
        if (!(roomID in roomToClientIDs)) {
          roomToClientIDs[roomID] = {}
        }
        roomToClientIDs[roomID][clientID] = true
        clientIDtoRooms[clientID][roomID] = true

        // For now, just automatically create the room if it doesn't exist, although we'll
        // revisit this later

        const roomsMessage = RoomsMessage.check({ type: "rooms", rooms: Object.keys(clientIDtoRooms[clientID]) })
        ws.send(JSON.stringify(roomsMessage))
        // For now, just automatically create the room if it doesn't exist, although we'll
        // fix this later
        // Reply with a RoomMessage
      } else {
        // As long as the if-else above is exhaustive over all possible client messages,
        // this is a good sanity check
        console.error(`Bad message: ${JSON.stringify(message, null, 2)}`)
      }
    })
  )
  ws.addEventListener("close", () => {
    try {
      ws.terminate()
    } catch (err) {}

    Object.keys(clientIDtoRooms[clientID]).forEach((room) => {
      delete roomToClientIDs[room][clientID]
    })
    delete clientIDtoRooms[clientID]
    delete clientIDtoWebsocket[clientID]

    // TODO: Update various mappings appropriately
  })
})

const client = new OAuth2Client(process.env.GOOGLE_CLIENT_ID)

//let dummyCount = 0 // TODO: Remove both of these variables once an actual user identity service is implemented
//const clientIDToDummyNumber: Map<ClientID, number> = new Map<ClientID, number>()

//const GOOGLE_CLIENT_ID = "948918026196-q49uid1opmf7oid570ptpl7kd1alcjru.apps.googleusercontent.com" // This is the application-wide client id for accessing the Google API

async function retrieveDisplayName(
  googleIDToken: string
  //clientID: ClientID /* We will need to replace this with a bearer token and implement an identity service in order to give this method actual functionality */
): Promise<string> {
  const ticket = await client.verifyIdToken({
    idToken: googleIDToken,
    audience: process.env.GOOGLE_CLIENT_ID, // Specify the CLIENT_ID of the app that accesses the backend
    // Or, if multiple clients access the backend:
    //[CLIENT_ID_1, CLIENT_ID_2, CLIENT_ID_3]
  })
  const payload = ticket.getPayload()
  const userFullName = payload ? payload["name"] : ""

  return userFullName ? userFullName : "" // TODO: Add option to go anonymous
  /*
  if (!clientIDToDummyNumber.has(clientID)) {
    clientIDToDummyNumber.set(clientID, ++dummyCount) // This is a dummy method for now
  }
  const dummyNum = clientIDToDummyNumber.get(clientID)
  return "Thing " + dummyNum?.toString() */
}

// Eventually we'll need to add a MongoDB connection, but we can keep this simple for now

// This is the actual part where we start the server
const port = process.env.BACKEND_PORT ? parseInt(process.env.BACKEND_PORT) : 8888
app.use(bodyParser()).use(websocket()).use(router.routes()).use(router.allowedMethods()).use(cors()).listen(port)

process.on("uncaughtException", (err) => {
  console.error(err)
})
